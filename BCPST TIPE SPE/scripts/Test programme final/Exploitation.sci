function [miroir]=vecteurnormal(A,B,C)
//miroir est le vecteur normal du plan 
// A,B,C 3 points du plan coordonnées x,y,z
M=[A';B';C'];
M(:,4)=[1;1;1];
miroir=kernel(M);
miroir=1/miroir(1)*miroir
endfunction


function [B]=sympoint(plan,A)
  t=-(plan(1)*A(1)+plan(2)*A(2)+plan(3)*A(3)+plan(4))/(plan(1)**2+plan(2)**2+plan(3)**2)
  B(1)=A(1)+plan(1)*2*t;
  B(2)=A(2)+plan(2)*2*t;
  B(3)=A(3)+plan(3)*2*t;
endfunction


function [vd2]=symdroite(vd,cam,plan,cam2)
  pt=sympoint(plan,[vd(1)*100+cam(1),vd(2)*100+cam(2),vd(3)*100+cam(3)]);
  vd2=[pt(1)-cam2(1),pt(2)-cam2(2),pt(3)-cam2(3)];  
endfunction


function [y]=distance(vd1,vc1,vd2,vc2)
  w=[vd1;vd2];
  n=kernel(w), // on obtient dans n le vecteur directeur de la droite orthogonale aux deux autres (produits scalaire nul) 
  V=[vc1(1)-vc2(1),vd1(1),-vd2(1),-n(1);vc1(2)-vc2(2),vd1(2),-vd2(2),-n(2);vc1(3)-vc2(3),vd1(3),-vd2(3),-n(3)];
  S=kernel(V), // on cherche les deux points appartenants aux deux droites qui forment un segment colnÃ©aire Ã  n
  x=1/S(1);
  S=S*x;
  p1(1)=vc1(1)+S(2)*vd1(1);
  p1(2)=vc1(2)+S(2)*vd1(2);
  p1(3)=vc1(3)+S(2)*vd1(3);
  p2(1)=vc2(1)+S(3)*vd2(1);
  p2(2)=vc2(2)+S(3)*vd2(2);
  p2(3)=vc2(3)+S(3)*vd2(3);
  y=[(p1(1)+p2(1))/2,(p1(2)+p2(2))/2,(p1(3)+p2(3))/2,(p1(1)-p2(1))**2+(p1(2)-p2(2))**2+(p1(3)-p2(3))**2];
  //les coordonnÃ©es du point assimilÃ© Ã  l'intersection des droites ainsi que la distance min entre les deux droites
endfunction 



function []=samaradraw(tableau);
  param3d(tableau(:,1),tableau(:,2),tableau(:,3),35,45,"X@Y@Z",[2,4])
endfunction



function [y]=norme(vd);  
    y=sqrt(vd(1)**2+vd(3)**2+vd(3)**2)
endfunction



function [y]=disteuc(A,B);  
    y=sqrt((A(1)-B(1))**2+(A(2)-B(2))**2+(A(3)-B(3))**2);
endfunction


function [T]=exploitation(tableau)
A=[4.5;-3.5;0];
B=[4.5;-3.5;10];
C=[71;2;0]; // A,B,C trois points du miroir
plan=vecteurnormal(A,B,C); // a,b,c,d tq ax+by+cz+d=0 est l'équation du plan du miroir
cam=[274.5;322;65]; // coordonnees de la cam
regle1=[-1;-1;30];   // coordonnees de la regle sur la droite de la photo (origine)
regle2=[-13;85.5;20]; // regle large bord le plus court
regle2=sympoint(plan,regle2); // cordonnees virtuelles vu dans la photo

r=1/(0.68*2); //rapport entre centre et echelle de la photo
t=poly(0,"t");
vd1=[regle2(1)-cam(1);regle2(2)-cam(2);regle2(3)-cam(3)]; 
vd1=vd1/sqrt(vd1(1)**2+vd1(2)**2+vd1(3)**2); // vd1 vecteur directeur entre cam et regle2
P=regle1(1)+r*(cam(1)+vd1(1)*t-regle1(1)); //cf geometrie
Q=regle1(2)+r*(cam(2)+vd1(2)*t-regle1(2));
R=regle1(3)+r*(cam(3)+vd1(3)*t-regle1(3));
S=(P-cam(1))*(P-regle1(1))+(Q-cam(2))*(Q-regle1(2))+(R-cam(3))*(R-regle1(3)); // Pscal nul
ro=roots(S); // on cherche l'inconnu t
t=ro(2); // on prend t positif
[str]=pol2str(P); 
x=evstr(str); //P(roots)
[str]=pol2str(Q);
y=evstr(str); //Q(roots)
[str]=pol2str(R);
z=evstr(str); // R(roots)
vd=[x-cam(1);y-cam(2);z-cam(3)];
vd=vd/sqrt(vd(1)**2+vd(2)**2+vd(3)**2);

//milieu verticale de la photo: 28.9 cm
dist=sqrt((regle1(1)-cam(1))**2+(regle1(2)-cam(2))**2+(regle1(3)-cam(3))**2)
X=cam+dist/sqrt(vd(1)**2+vd(2)**2+vd(3)**2)*vd
//X(3)=28.9
theta=atan((cam(2)-X(2))/(cam(1)-X(1)))
A=A-X;
B=B-X;
C=C-X;
regle1=regle1-X;
regle2=regle2-X;
cam=cam-X;
theta=-theta
M=[cos(theta),-sin(theta),0;sin(theta),cos(theta),0;0,0,1]
A=M*A;
B=M*B;
C=M*C;
regle1=M*regle1;
regle2=M*regle2;
cam=M*cam;
phi=atan(cam(3)/cam(1)),
//phi=-phi;
N=[cos(phi),0,sin(phi);0,1,0;-sin(phi),0,cos(phi)];
A=N*A;
B=N*B;
C=N*C;
regle1=N*regle1;
regle2=N*regle2;
cam=N*cam;
plan=vecteurnormal(A,B,C);
cam2=sympoint(plan,cam)
s=size(tableau);
T=zeros(s(1),4)
for i=1:s(1) do 
    vd1=[0-cam(1),tableau(i,1)-cam(2),tableau(i,2)-cam(3)];
     //Vecteur directeur de la droite 1 entre la cam et le projeté de la samare dans plan règle
vd2=[0-cam(1),tableau(i,3)-cam(2),tableau(i,4)-cam(3)];
[vd2]=symdroite(vd2,cam,plan,cam2);
T(i,:)=distance(vd1,cam,vd2,cam2);
Vect=[T(i,1);T(i,2);T(i,3)]
Vect=[cos(-phi),0,sin(-phi);0,1,0;-sin(-phi),0,cos(-phi)]*Vect;
Vect=[cos(-theta),-sin(-theta),0;sin(-theta),cos(-theta),0;0,0,1]*Vect;
Vect=Vect+X;
T(i,1)=Vect(1);
T(i,2)=Vect(2);
T(i,3)=Vect(3);
T=real(T);
end
endfunction



function [T]=exploit(path)
A=[4.5;-3.5;0];
B=[4.5;-3.5;10];
C=[71;2;0]; // A,B,C trois points du miroir
plan=vecteurnormal(A,B,C); // a,b,c,d tq ax+by+cz+d=0 est l'équation du plan du miroir
cam=[274.5;322;65]; // coordonnees de la cam
regle1=[-1;-1;30];   // coordonnees de la regle sur la droite de la photo (origine)
regle2=[-13;85.5;20]; // regle large bord le plus court
regle2=sympoint(plan,regle2); // cordonnees virtuelles vu dans la photo

r=1/(0.68*2); //rapport entre centre et echelle de la photo
t=poly(0,"t");
vd1=[regle2(1)-cam(1);regle2(2)-cam(2);regle2(3)-cam(3)]; 
vd1=vd1/sqrt(vd1(1)**2+vd1(2)**2+vd1(3)**2); // vd1 vecteur directeur entre cam et regle2
P=regle1(1)+r*(cam(1)+vd1(1)*t-regle1(1)); //cf geometrie
Q=regle1(2)+r*(cam(2)+vd1(2)*t-regle1(2));
R=regle1(3)+r*(cam(3)+vd1(3)*t-regle1(3));
S=(P-cam(1))*(P-regle1(1))+(Q-cam(2))*(Q-regle1(2))+(R-cam(3))*(R-regle1(3)); // Pscal nul
ro=roots(S); // on cherche l'inconnu t
t=ro(2); // on prend t positif
[str]=pol2str(P); 
x=evstr(str); //P(roots)
[str]=pol2str(Q);
y=evstr(str); //Q(roots)
[str]=pol2str(R);
z=evstr(str); // R(roots)
vd=[x-cam(1);y-cam(2);z-cam(3)];
vd=vd/sqrt(vd(1)**2+vd(2)**2+vd(3)**2);

//milieu verticale de la photo: 28.9 cm
dist=sqrt((regle1(1)-cam(1))**2+(regle1(2)-cam(2))**2+(regle1(3)-cam(3))**2)
X=cam+dist/sqrt(vd(1)**2+vd(2)**2+vd(3)**2)*vd
//X(3)=28.9
theta=atan((cam(2)-X(2))/(cam(1)-X(1)))
A=A-X;
B=B-X;
C=C-X;
regle1=regle1-X;
regle2=regle2-X;
cam=cam-X;
theta=-theta
M=[cos(theta),-sin(theta),0;sin(theta),cos(theta),0;0,0,1]
A=M*A;
B=M*B;
C=M*C;
regle1=M*regle1;
regle2=M*regle2;
cam=M*cam;
phi=atan(cam(3)/cam(1)),
//phi=-phi;
N=[cos(phi),0,sin(phi);0,1,0;-sin(phi),0,cos(phi)];
A=N*A;
B=N*B;
C=N*C;
regle1=N*regle1;
regle2=N*regle2;
cam=N*cam;
plan=vecteurnormal(A,B,C);
cam2=sympoint(plan,cam)
//Ouverture et lecture du fichier excel. Les chaines de caracteres sont dans SST, les valeurs numeriques dans Value.
//[fd,SST,Sheetnames,Sheetpos] = xls_open('C:\Users\Thibault\Desktop\tipe\Fichiers excel\Pointages\Samare_'+string(path)+'.xls');
[fd,SST,Sheetnames,Sheetpos] = xls_open('F:\TIPE\Pointages\'+string(path)+'.xls');
[tableau1,TextInd] = xls_read(fd,Sheetpos(1));
mclose(fd);
si=size(tableau1);
r=isnan(tableau1);
for i=1:si(1) do for j=1:si(2) do if r(i,j)==%F then tableau(i,j)=tableau1(i,j);end end end

s=size(tableau);
T=zeros(s(1),4)
for i=1:s(1) do 
    vd1=[0-cam(1),tableau(i,1)-cam(2),tableau(i,2)-cam(3)];
     //Vecteur directeur de la droite 1 entre la cam et le projeté de la samare dans plan règle
vd2=[0-cam(1),tableau(i,3)-cam(2),tableau(i,4)-cam(3)];
[vd2]=symdroite(vd2,cam,plan,cam2);
T(i,:)=distance(vd1,cam,vd2,cam2);
Vect=[T(i,1);T(i,2);T(i,3)]
Vect=[cos(-phi),0,sin(-phi);0,1,0;-sin(-phi),0,cos(-phi)]*Vect;
Vect=[cos(-theta),-sin(-theta),0;sin(-theta),cos(-theta),0;0,0,1]*Vect;
Vect=Vect+X;
T(i,1)=Vect(1);
T(i,2)=Vect(2);
T(i,3)=Vect(3);
T=real(T);
end
endfunction



function [vect]=surexploitation(T)
  s=size(T)
  n=floor(max(s)/10)
  M=0;N=0;Systeme=0;Milieu=zeros(1,3); //initialisation
  for i=1:n do
      M(i,1)=mean(T([10*i-9;10*i-8;10*i-7;10*i-6;10*i-5;10*i-4;10*i-3;10*i-2;10*i-1;10*i],1));
      M(i,2)=mean(T([10*i-9;10*i-8;10*i-7;10*i-6;10*i-5;10*i-4;10*i-3;10*i-2;10*i-1;10*i],2));
      M(i,3)=mean(T([10*i-9;10*i-8;10*i-7;10*i-6;10*i-5;10*i-4;10*i-3;10*i-2;10*i-1;10*i],3));
  end
  for i=1:n-1 do
      p=-(M(i,1)-M(i+1,1))/(M(i,2)-M(i+1,2));
      N(i,1)=p;
      N(i,2)=-1;
      N(i,3)=-p*(M(i,1)+M(i+1,1))/2+(M(i,2)+M(i+1,2))/2;
      DZ(i)=abs(M(i+1,3)-M(i,3));
  end
  for j=1:n-2 do
      Systeme=N([j;j+1],:);
      X=kernel(Systeme);
      Milieu(j,:)=X'/X(3);
  end
  vect(3)=mean(Milieu(:,1));//X(Centre)
  vect(4)=mean(Milieu(:,2));//Y(centre)
  for i=1:max(s) do
      d(i)=sqrt((T(i,1)-vect(3))**2+(T(i,2)-vect(4))**2);
  end
  vect(1)=mean(d); //Rayon
for i=1:n-1 do 
  X1=M(i,1)-vect(3);
  Y1=M(i,2)-vect(4);
  X2=M(i+1,1)-vect(3);
  Y2=M(i+1,2)-vect(4);
  d1=sqrt(X1**2+Y1**2);
  d2=sqrt(X2**2+Y2**2);
  X1=X1/d1;
  X2=X2/d2;
  Y1=Y1/d1;
  Y2=Y2/d2;
  theta(i)=asin(X1*Y2-X2*Y1);
end
  vect(2)=mean(theta)/10; //angle realisé par image (moyenne)
  vect(5)=mean(DZ)/10; // Delta Z par image (moyenne)
  //vect(2)=2*%pi/vect(2); // nombre d'images pour faire un tour
//  vect(5)=vect(5)*vect(2); //delta Z lors d'un tour 
  endfunction
  

